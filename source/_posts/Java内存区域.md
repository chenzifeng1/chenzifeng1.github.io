---
title: Java内存区域
date: 2020-06-22 14:24:49
tags:
---
# Java内存区域

## 运行时数据区
<!-- ![java运行时数据区](../picture/java运行时数据区.png)   -->
{% asset_img java运行时数据区.png java运行时数据区%}  
JVM在运行java进程时会将管理的内存分为若干个区域，我们根据线程之间的是否共享来对内存进行划分    
在jdk1.6时：  
-  线程共享的区域：堆，方法区（包括常量池），直接内存（这部分不属于运行时数据区）   
-  线程独占的区域：虚拟机栈，本地方法栈，程序计数器

在jdk1.8时：在运行时数据区移出了方法区，在直接内存里面添加了元空间  
-  线程共享：堆，直接内存（包括元空间）  
-  线程独占：虚拟机栈，本地方法栈，程序计数器  

下面介绍各个区域：
1. 程序计数器：如同OS中的程序计数器一样，记录下一条指令的内存地址。由于每个线程在不同的CPU上并发执行，所以每个线程都会独占一个程序计数器，来记录线程执行中的下一条字节指令的地址。OS中PC是有一个专属寄存器来存放下一条机器指令的内存地址，在java中在内存中单独为每个线程分配一块空间来存放下一条指令的地址。程序计数器两个作用：  
    1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理
    2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候恢复到指令跳转时的位置  
2. 虚拟机栈：虚拟机栈也是线程私有的，其生命周期与线程相同，当线程被销毁时，该内存会被回收。java内存可以粗糙的分为堆空间和栈空间，其中栈空间就是虚拟机栈，或者说栈空间是虚拟机栈的局部变量表部分。虚拟机栈是由一个个栈帧组成的，每个栈帧都拥有：局部变量表、操作数栈、动态链接、方法出口信息。局部变量表主要存放了编译器可知的各种数据类型（八种基本类型）以及对象引用（reference类型，根据对象寻址方式不同，对象引用可以是对象内存地址，也可以是指向对象地址的句柄）  
虚拟机栈可能出现的两种异常：
    1. StackOverFlowError
    2. OutOfMemoryError
3. 本地方法栈:由于jvm底层是由c,c++以及汇编写的，所以底层会调用一些native方法（即C）


4. 堆：heap又被称为GC堆，因为堆是垃圾回收的主要内存区域。堆分为年轻代和年老代  
{% asset_img GC-堆内存模型.PNG GC-堆内存模型%}  
当我们new一个对象的时候，jvm会根据对象大小为对象分配内存空间。若对象过大，则会被分配到老年代，一般对象首次创建放在年轻代的Eden区，当对象达到一定年龄（默认CMS6次，其他15次GC）将对象放到年老代。  

5. 方法区：与堆一样是线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区包括运行时常量池，比如说字符串常量池，这些我会开篇新博客讲述

