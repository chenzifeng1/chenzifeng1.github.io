---
title: Redis进阶之路
date: 2020-09-07 18:00:00
tags: redis
---
# Redis进阶之路（一）
## redis介绍

Redis是C语言开发的一个内存型数据库，相比传统的数据库，redis读写的速度非常快，因此常被用做缓存方向。

Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。

Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。

## 数据结构

1. **string:**

    string数据结构是简单的`key-value` 类型，使用自己构建的**简单动态字符串（simple dynamic string，SDS）**,相比于C的原生字符串，SDS既可以保存文本数据，又可以保存二进制数据，且获取字符串长度的复杂度为O(1) ,另外，Redis的SDS API是安全的，不会造成缓冲区溢出。

    **应用场景：**一般用于需要计数的场景，比如说用户访问次数、热点文章的点赞转发数。当一个数据重要性较低且会频繁变更时，我们可以使用redis的string进行缓存，然后定时进行持久化，这样可以略去每次更改就要进行数据库写操作的开销。

    **常用命令：**`set,get,strlen,exists,dect,incr,setex` ****或者是使用`help @string` 来查看相关命令

2. **list：**redis链表的链表实现是一个**双向链表**，虽然带来了部分额外内存开销，但可以支持反向查找和遍历，操作更简单，而且由于是双向链表，可以更简单完成**队列**与**栈**的实现。

    **应用场景：**订阅与发布、消息队列、慢查询(记录执行较慢的sql语句)

    **常用命令：**`lpush,rpush,lpop,rpop,lrange,llen`

    用例：

    1. 借助list实现队列：我们只要从list一头压入数据，另一头取出数据就实现了队列的结构.

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94e9c22c-0989-475a-a84c-8a7e6997a4aa/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94e9c22c-0989-475a-a84c-8a7e6997a4aa/Untitled.png)

    2. 借助list实现栈：

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8cc038be-fde6-4544-a670-6af038066b61/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8cc038be-fde6-4544-a670-6af038066b61/Untitled.png)

3. **hash：**redis的hash相当于jdk1.8之前的HashMap,内部实现也相似（**数组+链表**），但是redis的hash做了更多的优化，hash是一个string类型的field和value的映射表，特别适合用于存储对象。后续操作时，可以仅改变对象中的某个字段的值。

    **应用场景：**系统中对象数据的存储，如hash数据结构来存储用户信息，商品信息。

    **常用命令：**`hset,hmset,hexists,hget,hgetall,hkeys,hvals` 

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/179051ad-a845-4186-a1d3-248013918272/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/179051ad-a845-4186-a1d3-248013918272/Untitled.png)

4. **set：**类似java中的`HashSet` ,redis中的set类型是一种无序集合，集合元素没有先后顺序，当我们需要存储一个列表数据，又不希望有重复元素时，可以选择set。set提供了判断元素是否在set集合内的接口，这个时list无法提供的。且可以基于set实现交集，并集，差集等操作。

    **应用场景：**需要存放不重复数据以及获取多个数据源的集合操作。如可以利用set实现共同关注，共同粉丝等功能。

    **常用指令：**

    - `sadd key member [member ...]` :向set集合添加元素。
    - `spop key [count]` :从set集合弹出count个元素
    - `smembers key` :查询集合中的元素。
    - `sinterstore destination key [key ...]` :获取多个集合的交集并将其存入destination集合中。
    - `sunion key [key ...]` :获取多个集合的并集
5. **zset（sorted set）：**类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。内部实现用的是一种叫做 `「跳跃表」` 的数据结构

## Redis单线程模型

  Redis基于Reactor模式开发设计了自己的一套高效的事件处理模型，这套事件处理模型对应的是Redis中的**文件事件处理器(file event handler)**。由于文件事件处理器是单线程运行的，所以我们说redis是单线程模型。

 Redis通过IO多路复用来监听大量客户端连接（或者是多个Socket），它会将需要监听的事件及类型（读、写）注册到内核中，并监听每个事件是否发生。Redis通过**I/O多路复用**技术使Redis相比传统I/O阻塞模型来说，不需要额外创建多余线程来监听客户端的Socket，减少了资源消耗（就像NIO中的Selector）。

此外，Redis服务器是一个事件驱动程序，需要处理两类时间：1.文件事件，2.时间事件 

我们主要关注**文件事件，**引用《Redis设计与实现》中关于对文件事件的描述：

> 1.  Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。                                                                 2. 2.  当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。           3.  虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。

由此可知，Redis的网络通讯模型包括四个部分：

1. 多个客户端的Socket连接
2. I/O多路复用程序
3. 文件事件分派器
4. 事件处理器

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c747c67-e061-4a65-8bbb-0b266d2d8008/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c747c67-e061-4a65-8bbb-0b266d2d8008/Untitled.png)

由于Redis的性能瓶颈在内存和网络，所以相比于使用多线程模式所带来的额外开销和复杂度的提升，单线程模式更加方便适用。

## Redis过期时间+内存淘汰机制

如果我们不给数据设过期时间，那么内存很快就会因为缓存了大量数据而导致OOM，由于内存空间成本相对较高， 我们只需要热点数据缓存在内存中，对于那些不常用的数据留在内存中并不合适。

当然，给redis数据设置过期时间除了缓解内存消耗，还可以根据过期时间实现一些功能，如短信验证码的有效时间，用户token的有效时间，都可以通过设置数据过期时间来实现。

### 判断数据过期时间

Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。

```c
typedef struct redisDb {
    ...

    dict *dict;     //数据库键空间,保存着数据库中所有键值对
    dict *expires   // 过期字典,保存着键的过期时间
    ...
} redisDb;
```

Redis数据库的数据结构如上，其中有两个引用类型的字段`dict *dict`和`dict *expires`。

- dict *dict：数据库键空间，保存着数据库中所有键值对。或者说保存着所有键值对的key值及value的地址。这样我们可以通过key去找到对应的value。
- dict *expires：该指针变量指向Redis的过期字典，过期字典中保存着所有键的过期时间。

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb5cb602-994c-43cc-8d47-6bb9101bbf77/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb5cb602-994c-43cc-8d47-6bb9101bbf77/Untitled.png)

### 过期数据删除策略

常用的过期删除策略就两个：

- 定时删除：每隔一段时间抽取一批key执行过期时间删除，并且，redis会通过限制删除操作的时间和频率来减少删除操作对CPU的影响。
- 惰性删除：只有取出key的时候才进行过期检查，这样对CPU比较友好，但是可能会导致大量的过期key保留在内存中。

如何制定删除策略是自己造缓存轮子的时候需要额外考虑的东西。两种主要的删除策略各有优略，定期删除对内存更友好，惰性删除对CPU更友好。redis采取的是**定期删除+惰性删除**的结合。

但是，仅设置key的过期时间是不够的，两种删除策略依然会漏掉很多过期的key，随着时间的积累，依旧可能存在OOM的情况。为了解决这个问题，redis引入了**内存淘汰机制**

### 内存淘汰机制

Redis 提供 6 种数据淘汰策略：

1. **volatile-lru（least frequently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
2. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

**相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?**

redis缓存的数据只有数据全量的1%，我们要保证这20w数据尽可能都是热点数据以及这些数据有尽可能高的命中率，作为缓存机制来说，当数据不命中的处罚可能比直接查数据库更消耗时间。所以，面对保存大量热点数据的应用场景，首先20W条数据体量对内存来说是个不小的开销，我们应该尽量减少其他内存开销，如果选用过期key的内存淘汰策略，我们还需要去维护每个key 的过期时间，增加了内存开销。其次，维护热点数据需要将不常用的数据淘汰，综上，我们选择**`allkeys-lru` （least recently used）**这个内存淘汰策略。

## Redis持久化机制

在很多场景下，我们需要将缓存数据持久化，大部分原因是为了重用数据或者是进行数据备份，防止系统故障而导致数据丢失。redis持久化有两种方式：

- 快照（snapshotting，RDB）:Redis通过创建快照来获取内存中数据在某个时间节点的副本，Redis创建快照后，可以对快照进行备份，将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在本地以便重启服务的时候用。

    快照持久化是Redis默认的持久化方式，在Redis.conf配置文件中，默认有一下配置。

    ```c
    save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

    save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

    save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
    ```

- 只追加文件（append only file，AOF）:相比快照持久化，AOF持久化的实时性更好，因此已经成为主流的持久化方案。默认情况下，redis没有开启AOF的持久化方式，可以通过配置参数`appendlony yes` 来开启AOF持久化方式。开启AOF之后，每执行一条更改Redis中数据 的命令，Redis就会将该命令写入硬盘的AOF文件中。AOF文件位置和RDB一样，都是通过dir参数设置的，默认文件名是：`appendonly.aof`

    在Redis配置中，有三种不同AOF持久化方式：

    ```markdown
    appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
    appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
    appendfsync no        #让操作系统决定何时进行同步
    ```

    为了兼顾数据和写入性能，可以选用`appendsync everysec` 的方式，每秒钟对AOF文件同步一次，这样Redis性能影响很小，而且其实出现系统崩溃，用户损失也只是 一秒内的数据。

    **补充：AOF重写**

    AOF重写的结果是产生一个与原AOF文件具有相同数据状态，但是文件大小更小的AOF文件。通过读取数据库中的键值对来实现AOF重写，那么问题是如何保证在重写过程中，新的写入操作不会丢失。解决方案，在执行`BGERWRITEAOF` 命令之后，Redis会wei'hu一个*AOF重写缓冲区*，当在复制新的AOF文件的同时，如果有新的写命令，那么就会被缓存在这个缓冲区内，当复制完原有AOF文件后，再把缓冲区的内容追加到新的文件末尾，使得新旧两个AOF文件所保持的数据库状态一致。然后用新的AOF文件去替换旧的文件。

## Redis事务

关系型数据库事务的四大特征：

- 原子性：事务是最小的执行单位，不可分割。对于事物所包含的操作，要么全部完成，要么全部不起作用。
- 一致性：事务执行前后数据保持一致，多个事务对同一个数据读取结果是相同的。
- 隔离性：数据库之间的事务是相互隔离的，一个事务的执行不会被其他并发执行的事务所影响。
- 持久性：一个事务提交之后，对数据库做的改变是永久的，即使数据库故障也不会影响改变

Redis的事务：Redis不支持**Roll Back**，无法进行Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。

## 解决缓存问题

### 缓存穿透

大量请求的key不在缓存中，所以这些请求就直接落到了数据库这一层，根本没有经缓存层。比如说，黑客故意制造缓存不存在的key发起大量请求，导致大量请求落到数据库，而数据库的DPS有限，过多的请求会导致数据库崩溃。

**解决方法：**

最基本的是做好参数校验，对于不合法或者是无意义的参数直接抛出异常返回给前端。

1. 缓存无效key

    如果缓存和数据库都查不到某个key的数据，就写一个到redis中并 设置过期时间，具体命令如下：`SET key value EX 10086`  设置key的value值并设置过期时间。这种方式可以解决请求key变换不频繁的情况，说白了就是造一个与请求key相同的数据，让下一次请求这个key请求可以在缓存层命中。但是弊端很明显，如果黑客制造了大量无效且不同的key，那么我们的缓存会突然增加大量的无效数据，而缓存层一般是在内存中，这样会导致内存开销剧增，最后导致OOM。如果非要用这个方法来解决缓存穿透的问题，那可以将过期时间设的短一点。

2. 布隆过滤器:一个特殊的数据结构，我们可以把所有key可能的取值都放进布隆过滤器中，然后每次对请求的key进行校验来判断请求的key是否合法有效。**注意：布隆过滤器可能会存在误判，但是概率比较小，如果布隆过滤器判断一个key存在，那有小概率可能性这个key不在；但是，如果布隆过滤器判断一个key不存在，那这个key肯定不存在。**

    我们可以把**布隆过滤器**看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。

    [Snailclimb/JavaGuide](https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md)

### 缓存雪崩

**场景**

1. 缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。

    举例：：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。

2. 有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。

    举例：比如在货品秒杀场景下，我们提前12小时在缓存中放入了参与秒杀的商品，数据的过期时间是12小时，那么秒杀刚开始，数据就过期了，导致这些数据的请求直接落到了数据库层，可能会直接挂掉数据库。