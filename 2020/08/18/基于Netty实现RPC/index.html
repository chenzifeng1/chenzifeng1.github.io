<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="陈子枫"><meta name="copyright" content="陈子枫"><meta name="generator" content="Hexo 4.2.1"><meta name="theme" content="hexo-theme-yun"><title>基于Netty实现RPC | 江湖夜雨</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;family=Source+Code+Pro&amp;display=swap" media="none" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_pem9yni52s.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"满堂花醉三千客一剑霜寒十四州","version":"0.9.0","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="RPC进阶之路（三）Netty协议源码阅读  Netty-4.1.x :  http:&#x2F;&#x2F;docs.52im.net&#x2F;extend&#x2F;docs&#x2F;src&#x2F;netty4_1&#x2F; Netty-4.0.x:  http:&#x2F;&#x2F;docs.52im.net&#x2F;extend&#x2F;docs&#x2F;src&#x2F;netty4&#x2F; Netty-3.x   :  http:&#x2F;&#x2F;docs.52im.net&#x2F;extend&#x2F;docs&#x2F;src&#x2F;nett">
<meta property="og:type" content="article">
<meta property="og:title" content="基于Netty实现RPC">
<meta property="og:url" content="http://chenzifeng.com/2020/08/18/%E5%9F%BA%E4%BA%8ENetty%E5%AE%9E%E7%8E%B0RPC/index.html">
<meta property="og:site_name" content="江湖夜雨">
<meta property="og:description" content="RPC进阶之路（三）Netty协议源码阅读  Netty-4.1.x :  http:&#x2F;&#x2F;docs.52im.net&#x2F;extend&#x2F;docs&#x2F;src&#x2F;netty4_1&#x2F; Netty-4.0.x:  http:&#x2F;&#x2F;docs.52im.net&#x2F;extend&#x2F;docs&#x2F;src&#x2F;netty4&#x2F; Netty-3.x   :  http:&#x2F;&#x2F;docs.52im.net&#x2F;extend&#x2F;docs&#x2F;src&#x2F;nett">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/chenzifeng1/chenzifeng1.github.io/blob/master/picture/Netty-%E5%8C%85%E7%BB%93%E6%9E%84.png?raw=true">
<meta property="og:image" content="https://github.com/chenzifeng1/chenzifeng1.github.io/blob/master/picture/Netty-%E5%90%AF%E5%8A%A8%E7%B1%BB.png?raw=true">
<meta property="og:image" content="https://github.com/chenzifeng1/chenzifeng1.github.io/blob/master/picture/Netty-ChannelPipeline.PNG?raw=true">
<meta property="article:published_time" content="2020-08-18T08:00:04.000Z">
<meta property="article:modified_time" content="2020-08-25T02:27:35.991Z">
<meta property="article:author" content="陈子枫">
<meta property="article:tag" content="RPC，Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/chenzifeng1/chenzifeng1.github.io/blob/master/picture/Netty-%E5%8C%85%E7%BB%93%E6%9E%84.png?raw=true"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="陈子枫"><img width="96" loading="lazy" src="/../img/head.jpg" alt="陈子枫"></a><div class="site-author-name"><a href="/about/">陈子枫</a></div><a class="site-name" href="/about/site.html">江湖夜雨</a><sub class="site-subtitle">陈子枫的技术秘籍</sub><div class="site-desciption">一个菜鸟程序员的成长之路</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">9</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><a class="site-state-item hty-icon-button" href="https://yun.yunyoujun.cn" target="_blank" rel="noopener" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/chenzifeng1" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="https://lmikoto.com/" target="_blank" rel="noopener" title="大阳哥的博客（力推）" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="https://gochenryan.github.io/" target="_blank" rel="noopener" title="狗成的博客（看看就好）" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC进阶之路（三）"><span class="toc-number">1.</span> <span class="toc-text">RPC进阶之路（三）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty协议"><span class="toc-number">2.</span> <span class="toc-text">Netty协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty核心组件"><span class="toc-number">3.</span> <span class="toc-text">Netty核心组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty实现RPC"><span class="toc-number">4.</span> <span class="toc-text">Netty实现RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#协议处理"><span class="toc-number">4.1.</span> <span class="toc-text">协议处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#客户端"><span class="toc-number">4.2.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端"><span class="toc-number">4.3.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理"><span class="toc-number">4.4.</span> <span class="toc-text">代理</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://chenzifeng.com/2020/08/18/%E5%9F%BA%E4%BA%8ENetty%E5%AE%9E%E7%8E%B0RPC/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="陈子枫"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="江湖夜雨"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">基于Netty实现RPC</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-08-18 16:00:04" itemprop="dateCreated datePublished" datetime="2020-08-18T16:00:04+08:00">2020-08-18</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2020-08-25 10:27:35" itemprop="dateModified" datetime="2020-08-25T10:27:35+08:00">2020-08-25</time></div><div class="post-classify"><span class="post-tag"><a class="tag" href="/tags/RPC%EF%BC%8CNetty/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">RPC，Netty</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><h2 id="RPC进阶之路（三）"><a href="#RPC进阶之路（三）" class="headerlink" title="RPC进阶之路（三）"></a>RPC进阶之路（三）</h2><h2 id="Netty协议"><a href="#Netty协议" class="headerlink" title="Netty协议"></a>Netty协议</h2><p>源码阅读</p>
<ul>
<li>Netty-4.1.x :  <a href="http://docs.52im.net/extend/docs/src/netty4_1/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/src/netty4_1/</a></li>
<li>Netty-4.0.x:  <a href="http://docs.52im.net/extend/docs/src/netty4/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/src/netty4/</a></li>
<li>Netty-3.x   :  <a href="http://docs.52im.net/extend/docs/src/netty3/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/src/netty3/</a></li>
</ul>
<p>Netty在线API文档</p>
<ul>
<li>Netty-4.1.x API文档(在线版)：<a href="http://docs.52im.net/extend/docs/api/netty4_1/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/api/netty4_1/</a></li>
<li>Netty-4.0.x API文档(在线版)：<a href="http://docs.52im.net/extend/docs/api/netty4/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/api/netty4/</a></li>
<li>Netty-3.x API文档(在线版)：<a href="http://docs.52im.net/extend/docs/api/netty3/" target="_blank" rel="noopener">http://docs.52im.net/extend/docs/api/netty3/</a></li>
</ul>
<p>服务器在处理响应的设计模式有两种：</p>
<ul>
<li>线程驱动：同步阻塞就是线程驱动模式，即一个线程处理一个客户端建立的socket</li>
<li>事件驱动：I/O复用模型应该时事件驱动的。参考观察者模式，建立一个事件池，通过单线程监听事件池是否有待处理的事件，如果有的话，线程将事件取出进行处理。</li>
</ul>
<p>注意区分Java的NIO包与非阻塞I/O模型之间的区别。NIO包是java自带的基于异步非阻塞I/O模型(I/O多路复用模型)所实现的一个工具包；而NIO模型则是非阻塞I/O模型，实在传统阻塞I/O模型的基础上将socket设为非阻塞实现的。</p>
<h2 id="Netty核心组件"><a href="#Netty核心组件" class="headerlink" title="Netty核心组件"></a>Netty核心组件</h2><p>我们可以查看Netty依赖包的项目树来查看Netty都包括那些组件</p>
<p><img src="https://github.com/chenzifeng1/chenzifeng1.github.io/blob/master/picture/Netty-%E5%8C%85%E7%BB%93%E6%9E%84.png?raw=true" alt="Netty包结构" loading="lazy"></p>
<ul>
<li><p><strong>Bootstrap和ServerBootstrap:</strong> Netty应用程序通过设置Bootstrap的引导类来完成，该类提供了一个用于应用程序网络层配置的容器，服务端使用的是ServerBootstrap，客户端使用的是Bootstrap。</p>
<p>  <img src="https://github.com/chenzifeng1/chenzifeng1.github.io/blob/master/picture/Netty-%E5%90%AF%E5%8A%A8%E7%B1%BB.png?raw=true" alt="Netty启动器类" loading="lazy"></p>
</li>
<li><p><strong>Channel:</strong>Netty 中的接口 Channel 定义了与 socket 丰富交互的操作集：bind, close, config, connect, isActive, isOpen, isWritable, read, write 等等。</p>
</li>
<li><p><strong>ChannelHandler:</strong>ChannelHandler 支持很多协议，并且提供用于数据处理的容器，ChannelHandler由特定事件触发， 常用的一个接口是ChannelInboundHandler，该类型处理入站读数据（socket读事件）</p>
</li>
<li><p><strong>ChannelPipeline:</strong>按照我的理解，Netty由于采用了I/O复用模型，使单线程更好的处理Socket的操作，它会将多个ChannelHandler组成一个链式结构，每当一个channel中有Socket的事件需要处理时，就从ChannelHandler的处理链中选取一个ChannelHandler进行处理。为了更好的管理ChannelHandler链，我们需要ChannelPipiline提供一个容器在管理ChannelHandler，容器可以根据ChannelHandler的类型（处理Socket的读、写）分类管理。同时提供API来管理沿着链入站和出站事件的流动。每个 Channel 都有自己的ChannelPipeline，当 Channel 创建时自动创建的</p>
<p>  <img src="https://github.com/chenzifeng1/chenzifeng1.github.io/blob/master/picture/Netty-ChannelPipeline.PNG?raw=true" alt="ChannelPipeline模型" loading="lazy"></p>
</li>
<li><p><strong>EventLoop:</strong>处理channel的I/O操作，一个EventLoop会处理多个Channel中的I/O操作，一个EventLoopGroup通常会包括多个EventLoop，并且会提供一个迭代来检索。</p>
</li>
<li><p><strong>ChannelFuture:</strong>由于Netty的所有I/O操作都是异步的，因此可能无法立即返回结果，为了获取I/O操作的结果，Netty定义了ChannelFuture来获取结果。</p>
</li>
</ul>
<h2 id="Netty实现RPC"><a href="#Netty实现RPC" class="headerlink" title="Netty实现RPC"></a>Netty实现RPC</h2><h3 id="协议处理"><a href="#协议处理" class="headerlink" title="协议处理"></a>协议处理</h3><p>在这一部分，我们需要定义三部分：</p>
<ol>
<li>序列化接口及实现</li>
<li>编解码器</li>
<li>请求/响应参数体</li>
</ol>
<ul>
<li><p><strong>序列化接口及实现</strong></p>
<p>  在网络层传输中，我们的数据是以字节形式进行传输的。</p>
<p>  因此在接口中我们需要定义两种方法：一个是字节转Byte的方法，一个是Byte转字节的方法。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象序列化成字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object object) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字节数组反序列化成对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz,<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  定义好接口之后，我们需要定义其实现类,实现类的方式可以多种，这里我们选择JSON自带的对象转byte和 byte转对象的方法。之所以定义接口，是因为如果我们想更换序列化方法，只需要重写一个实现序列化接口的类即可，不需要更改太多代码。面向接口编程，开放封闭原则。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializerImpl</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONBytes(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz,<span class="keyword">byte</span>[] bytes)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(bytes,clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编解码器</strong></p>
<p>  当我们定义好序列化接口之后就可以将信息进行编码与解码了，在这里我们可以规定信息传输的协议：在编码器中，我们如何将拼接信息，信息头包括什么、信息体如何、校验码加在哪里等等；在解码器中，我们根据协议将接收的信息解码，获取信息体，信息头中的数据，可以对校验码进行校验，查看数据在传输过程中是否有丢包等问题。还可以通过策略模式调用不同的信息编解码策略，这些是可以做的，但是由于本篇内容仅作入门使用，故只做对象转byte与byte转对象。</p>
<p>  编码器：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcEncoder</span><span class="params">(Class&lt;?&gt; clazz, Serializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object o, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断一下初始化的编码器的信息类型是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (clazz!=<span class="keyword">null</span> &amp;&amp; clazz.isInstance(o) )&#123;</span><br><span class="line">            <span class="comment">//将信息编码</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = serializer.serialize(o);</span><br><span class="line">            <span class="comment">//字节流中写入字节长度</span></span><br><span class="line">            byteBuf.writeInt(bytes.length);</span><br><span class="line">            <span class="comment">//写入信息</span></span><br><span class="line">            byteBuf.writeBytes(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  解码器：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class clazz;</span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcDecoder</span><span class="params">(Class clazz, Serializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//因为编码时写入了一个int类型的数据，因此byteBuf里面的可读字节一定大于4，如果小于4则是无数据</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes()&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记当前读的位置</span></span><br><span class="line">        byteBuf.markReaderIndex();</span><br><span class="line">        <span class="keyword">int</span> dataLength = byteBuf.readInt();</span><br><span class="line">        <span class="comment">//如果当前可读字节数小于数据长度，重置当前读的位置</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes()&lt;dataLength)&#123;</span><br><span class="line">            byteBuf.resetReaderIndex();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将byteBuf中的数据读到data中</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        list.add(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>请求/响应参数体</strong></p>
<p>  我们通过定义请求、响应的参数体来对我们要传输的数据进行包装。</p>
<p>  请求体：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求对象Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求对象的类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  响应体：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应id ：请求Id和响应Id要保持一致，因为客户端和服务端只有通过一致的Id才能确定调用和</span></span><br><span class="line"><span class="comment">		 * 响应的是同一个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String errorInfo;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  请求与响应体的定义成这样是为了之后利用反射更灵活的获得对象实体。回归框架目的，我们使用Netty开发一个RPC框架，是为了完成远程过程调用。那么<strong>如何传参，如何定位到服务端的服务方法</strong>是框架必须考虑的事情<strong>。</strong>于是客户端和服务端需要制定共同遵守的协议，这样客户端向服务端发起过程方法调用请求时，服务端根据协议解析客户端的数据，就能知道具体调用哪个方法。其中<strong>RPCRequest</strong>的<strong>requestId</strong>，即请求对象ID是为了<strong>验证服务器请求和响应是否匹配。</strong></p>
</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>Netty客户端的实现注意以下几点：</p>
<ul>
<li>编写启动方法，指定传输使用Channel</li>
<li>指定ChannelHandler，对网络传输中的数据进行读写处理</li>
<li>添加编解码器</li>
<li>添加失败重试机制</li>
<li>添加发送请求消息的方法</li>
</ul>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 事件处理器集合：每个I/O操作都交给EventLoop来处理，</span></span><br><span class="line"><span class="comment">		 * 而EventLoopGroup里面通常包括大于一个的EventLoop</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="comment">//定义了与Socket进行交互的操作集</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//客户端处理器</span></span><br><span class="line">    <span class="keyword">private</span> ClientHandler clientHandler;</span><br><span class="line">    <span class="comment">//ip地址</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="comment">//端口</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="comment">//最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETRY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(String host, Integer port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//ClientHandler为Channel链提供了容器，以及驱动事件沿Channel链进出的API</span></span><br><span class="line">        clientHandler = <span class="keyword">new</span> ClientHandler();</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//启动类</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                <span class="comment">//指定传输用的Channel</span></span><br><span class="line">                .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">true</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">CONNECT_TIMEOUT_MILLIS</span>, 500)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">	                    <span class="meta">@Override</span></span><br><span class="line">	                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	                        ChannelPipeline channelPipeline = socketChannel.pipeline();</span><br><span class="line">	                        <span class="comment">//添加编码器</span></span><br><span class="line">	                        channelPipeline.addLast(<span class="keyword">new</span> RpcEncoder(RPCRequest<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">SerializerImpl</span>()))</span>;</span><br><span class="line">	                        <span class="comment">//添加解码器</span></span><br><span class="line">	                        channelPipeline.addLast(<span class="keyword">new</span> RpcDecoder(RPCResponse<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">SerializerImpl</span>()))</span>;</span><br><span class="line">	                        <span class="comment">//请求处理类</span></span><br><span class="line">	                        channelPipeline.addLast(clientHandler);</span><br><span class="line">	                    &#125;</span><br><span class="line">	                &#125;);</span><br><span class="line">        connect(bootstrap, host, port, MAX_RETRY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败重连机制</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bootstrap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Bootstrap bootstrap, String host, <span class="keyword">int</span> port, <span class="keyword">int</span> retry)</span> </span>&#123;</span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">"连接成功"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retry == <span class="number">0</span>) &#123;</span><br><span class="line">                log.error(<span class="string">"重连失败"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//重连次数</span></span><br><span class="line">                <span class="keyword">int</span> order = (MAX_RETRY - retry) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//本次重连间隔</span></span><br><span class="line">                <span class="keyword">int</span> delay = <span class="number">1</span> &lt;&lt; order;</span><br><span class="line">                log.error(<span class="string">"第 &#123;&#125; 次重连失败，时间：&#123;&#125;"</span>,order,<span class="keyword">new</span> Date());</span><br><span class="line">                <span class="comment">//定时任务</span></span><br><span class="line">                bootstrap.config().group().schedule( ()-&gt;connect(bootstrap,host,port,retry-<span class="number">1</span>),delay, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel = channelFuture.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送数据：使用channel将请求发送之后进入等待状态，如果响应来了会被唤醒，唤醒时说明ClientHandler响应对象中已经有请求对应的响应了，使用请求Id获取该响应即可。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RPCResponse <span class="title">send</span><span class="params">(<span class="keyword">final</span> RPCRequest rpcRequest)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           channel.writeAndFlush(rpcRequest).await();</span><br><span class="line">       &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">           log.error(<span class="string">"发送数据失败"</span>,e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> clientHandler.getRPCResponse(rpcRequest.getRequestId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//关闭通道，同步不可中断</span></span><br><span class="line">        eventLoopGroup.shutdownGracefully();</span><br><span class="line">        channel.closeFuture().syncUninterruptibly();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要实现客户端连接服务端的相关操作，我们可以看出客户端在连接服务端时做了几个操作：</p>
<ol>
<li>创建并设置客户端的启动类<code>Bootstrap</code>，设置包括I/O事件处理集<code>EventLoopGroup</code>、操作、指定传输用的channel以及I/O处理器，初始化<code>channel</code>。</li>
<li>连接服务端，设置失败重连机制，在一次连接失败时进行下次连接尝试</li>
</ol>
<p>客户端的代码更像是在配置Netty通讯的客户端环境，具体通信细节交给了代理来做，在客户端代码中，我们定义了一个<code>ClientHandler</code>的对象，该类继承了<code>ChannelDuplexHandler</code>(ChannelHandler的一个实现类)。在<code>ClientHandler</code>类里面，我们定义了关于客户端数据读写的方法，只不过在<code>NettyClient</code>里面我们只在ChannelPipeLine将<code>ClientHandler</code>设置为处理器。具体调用的位置是在代理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map维护请求对象ID和响应结果的映射关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String ,DefaultFuture&gt; futureMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 猜测：此处应该是建立响应结果与请求对象Id的映射关系，传过来的两个参数：</span></span><br><span class="line"><span class="comment">        * ChannelHandlerContext是一个接口</span></span><br><span class="line"><span class="comment">        * msg是传过来的响应数据</span></span><br><span class="line"><span class="comment">        * 验证猜测：猜测错误，此处是将传过来的msg封装为DefaultFuture的处理过程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RPCResponse)&#123;</span><br><span class="line">            RPCResponse rpcResponse = (RPCResponse) msg;</span><br><span class="line">            <span class="comment">//Map已经维护好了对应的映射关系</span></span><br><span class="line">            DefaultFuture defaultFuture = futureMap.get(rpcResponse.getResponseId());</span><br><span class="line">            <span class="comment">// 异步响应？</span></span><br><span class="line">            defaultFuture.setRpcResponse(rpcResponse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx,msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RPCRequest)&#123;</span><br><span class="line">            RPCRequest rpcRequest = (RPCRequest) msg;</span><br><span class="line">            <span class="comment">//在发送请求之前，首先在客户端维护一个请求的Id,并关联一个DefaultFuture的实例</span></span><br><span class="line">            futureMap.put(rpcRequest.getRequestId(),<span class="keyword">new</span> DefaultFuture());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.write(ctx,msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取响应数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> responseId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RPCResponse <span class="title">getRPCResponse</span><span class="params">(String responseId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultFuture defaultFuture = futureMap.get(responseId);</span><br><span class="line">            <span class="keyword">return</span> defaultFuture.getRpcResponse(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//获取响应之后移除对应关系</span></span><br><span class="line">            futureMap.remove(responseId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类中，我们定义了一个Map对象来维护请求对象Id和响应数据的映射关系，map的key是请求对象的Id,value是响应对象的接收类。</p>
<ul>
<li>当我们请求服务时，也就是进行<strong>写操作时</strong>，我们会将请求对象的Id以及一个新的DefaultFuture对象作为一个键值对存入<code>futureMap</code>中，然后调用父类的write方法，将内容写到Socket中去。</li>
<li>当我们得到服务端的响应时，也就是进行<strong>读操作时</strong>，我们会将消息转成<code>RPCResponse</code>的对象，再封装到DefaultFuture中。</li>
</ul>
<p>我们可以看一下<code>DefaultFuture</code>这个响应对象的接收类如何定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RPCResponse rpcResponse;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean isSuccess = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过wait()和notify()方法来实现异步调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOut</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RPCResponse <span class="title">getRpcResponse</span><span class="params">(<span class="keyword">int</span> timeOut)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!isSuccess)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait(timeOut);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRpcResponse</span><span class="params">(RPCResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">            <span class="keyword">this</span>.rpcResponse = rpcResponse;</span><br><span class="line">            <span class="keyword">this</span>.isSuccess = <span class="keyword">true</span>;</span><br><span class="line">            object.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultFuture类中有一个标识是否接收到数据的属性 <code>private volatile Boolean isSuccess = false;</code> 还有一个作为锁对象的属性  <code>private final Object object = new Object();</code> 。</p>
<p>由于Netty的I/O模型是异步非阻塞的，所以不管是在服务端还是客户端，工作线程都不会一直阻塞着等待socket的读写操作。在这里，我们通过对object加同步锁，来保证每次只有一个线程可以对同一个响应对象进行操作。标志属性<code>isSuccess</code> 一开始设为<code>false</code>，这样就算线程尝试读取响应对象，会被阻塞。当响应数据被set的时候，我们会将标志属性改为<code>true</code> ，这样当线程再次尝试获取响应对象的时候就可以进入循环。</p>
<p>我们假设有两个线程，一个进行读操作，一个进行写操作：写操作的线程先拿到object的同步锁，那读操作的线程进入循环，被阻塞。写线程写完数据之后，设置好标志属性，调用<code>notify()</code> 方法通知被阻塞的读线程，由于此时<code>isSuccess</code>是true,因此循环结束，返回数据。由此看Netty的异步也不是纯粹的异步，也有线程被阻塞等待的过程。（等待验证）</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>Netty服务端的实现跟客户端的实现差不多，只不过要注意的是，当对请求进行解码过后，需要通过代理的方式调用本地函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负责处理客户端连接的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup boss = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负责处理读写操作的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup worker = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServerHandler serverHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//可以使用Eureka或者Zookeeper做注册中心，暂不处理</span></span><br><span class="line"><span class="comment">//        ServiceRegistry registry  =new ZKServiceRegistry();\</span></span><br><span class="line">        ArrayList&lt;Class&lt;?&gt;&gt; categories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ServiceRegistry registry = <span class="keyword">new</span> ServiceRegistry(categories.iterator());</span><br><span class="line">        start(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ServiceRegistry registry)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//建立负责客户端连接的线程池</span></span><br><span class="line">        boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//建立负责读写操作的线程池</span></span><br><span class="line">        worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(boss, worker);</span><br><span class="line">        serverBootstrap.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        serverBootstrap.option(NioChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br><span class="line">        serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline channelPipeline = socketChannel.pipeline();</span><br><span class="line">                <span class="comment">//设置编码器</span></span><br><span class="line">                channelPipeline.addLast(<span class="keyword">new</span> RpcEncoder(RPCRequest<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">SerializerImpl</span>()))</span>;</span><br><span class="line">                <span class="comment">//设置解码器</span></span><br><span class="line">                channelPipeline.addLast(<span class="keyword">new</span> RpcDecoder(RPCResponse<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">SerializerImpl</span>()))</span>;</span><br><span class="line">                <span class="comment">//设置处理器</span></span><br><span class="line">                channelPipeline.addLast(serverHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bind(serverBootstrap, <span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverBootstrap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> ServerBootstrap serverBootstrap, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">"端口绑定成功 &#123;&#125;"</span>, port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">"端口绑定失败&#123;&#125;"</span>, port);</span><br><span class="line">                bind(serverBootstrap, port + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        boss.shutdownGracefully().sync();</span><br><span class="line">        worker.shutdownGracefully().sync();</span><br><span class="line">        log.info(<span class="string">"关闭Netty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前在介绍组件的时候就介绍过<code>EventLoopGroup</code> ，这个组件相当于线程池，存放<code>EevntLoop</code> ,<code>EevntLoop</code> 可以认为是负责处理socket读写操作的线程。但是在I/O复用模型中，只有一个线程来负责监听所有的I/Osocket的事件，这里有点不理解，还需要在学习和验证。另外服务端的启动类是<code>ServerBootstrap</code>，启动方法中初始化了负责处理客户端连接的线程池<code>boss</code>和负责处理I/O的线程池<code>worker</code> ，并且配置了启动类<code>ServerBootstrap</code> 。</p>
<p><code>EevntLoopGroup</code>  是一个接口，定义了注册方法以及提供用于遍历的API.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventLoopGroup</span> <span class="keyword">extends</span> <span class="title">EventExecutorGroup</span> </span>&#123;</span><br><span class="line">    <span class="function">EventLoop <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel var1, ChannelPromise var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与客户端代码相同的是，Server端代码一样需要一个<code>ChannelHandler</code> ，不过两者的ChannelHandler所做的工作不一样而已。下面看看Server端的ChannelHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RPCRequest</span>&gt; <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, RPCRequest rpcRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RPCResponse rpcResponse = <span class="keyword">new</span> RPCResponse();</span><br><span class="line">        rpcResponse.setRequestId(rpcRequest.getRequestId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//handler是服务端通过反射根据RPCRequest对象中的信息调用响应的方法。</span></span><br><span class="line">            Object handler = handler(rpcRequest);</span><br><span class="line">            log.info(<span class="string">"返回结果：&#123;&#125;"</span>,handler);</span><br><span class="line">            rpcResponse.setResult(handler);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">            rpcResponse.setErrorInfo(throwable.getMessage());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        channelHandlerContext.writeAndFlush(rpcResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端使用代理处理请求数据</span></span><br><span class="line"><span class="comment">     * 因为不知道请求数据的类型和属性</span></span><br><span class="line"><span class="comment">     * RPCRequest里面封装了关于请求数据Class类型和属性及方法的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handler</span><span class="params">(RPCRequest request)</span> <span class="keyword">throws</span> ClassNotFoundException,InvocationTargetException</span>&#123;</span><br><span class="line">        <span class="comment">//利用反射获取请求数据</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(request.getClassName());</span><br><span class="line">        Object serverBean = applicationContext.getBean(clazz);</span><br><span class="line">        log.info(<span class="string">"ServerBean: &#123;&#125;"</span>,serverBean);</span><br><span class="line">        Class&lt;?&gt; serverClass = serverBean.getClass();</span><br><span class="line">        log.info(<span class="string">"ServerClass：&#123;&#125;"</span>,serverClass);</span><br><span class="line">        String methodName = request.getMethod();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] parametersTypes = request.getParameterType();</span><br><span class="line">        Object[] parameters = request.getParameters();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用CGLIB Reflect</span></span><br><span class="line">        FastClass fastClass = FastClass.create(serverClass);</span><br><span class="line">        FastMethod fastMethod = fastClass.getMethod(methodName,parametersTypes);</span><br><span class="line">        log.info(<span class="string">"开始调用CGLIB动态代理执行服务端方法..."</span>);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">return</span> fastMethod.invoke(serverBean, parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器的ChannelHandler负责把客户端传过来的RPCRequest对象利用反射拿到对应的类对象，并调用响应的方法。RPCRequest对象的属性包括需要调用的类名，方法名，参数名和参数类型，服务端<code>ChannelHandler</code>的<code>handler</code> 方法就是根据这些属性来完成方法调用的，返回对象是object,这样是不是能做到客户端不需要持有服务端相应的类或接口了？（需要验证）</p>
<p> <code>channelHandlerContext.writeAndFlush(rpcResponse);</code> 将调用方法的返回值写回Channel中。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>这里我们把具体的通信细节放到代理类中实现，完成客户端和服务端的代码的解耦。代理部分分为一个代理类工厂和具体的代理类。</p>
<p>先看代理工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;interfaceClass&#125;, <span class="keyword">new</span> RpcClientDynamicProxy&lt;T&gt;(interfaceClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理工厂创建代理实例的过程 以后有时间会了解并进行补充。</p>
<p>查看具体的代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientDynamicProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clzz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientDynamicProxy</span><span class="params">(Class&lt;T&gt; clzz)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clzz = clzz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RPCRequest rpcRequest = <span class="keyword">new</span> RPCRequest();</span><br><span class="line">        String requestId = UUID.randomUUID().toString();</span><br><span class="line">        String className = method.getDeclaringClass().getName();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt;[] parameterType =  method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        rpcRequest.setRequestId(requestId);</span><br><span class="line">        rpcRequest.setClassName(className);</span><br><span class="line">        rpcRequest.setMethod(methodName);</span><br><span class="line">        rpcRequest.setParameterType(parameterType);</span><br><span class="line">        rpcRequest.setParameters(args);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"请求内容 &#123;&#125;"</span>,rpcRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启Netty服务端，直连</span></span><br><span class="line">        NettyClient client = <span class="keyword">new</span> NettyClient(SERVER_HOST,SERVER_PORT);</span><br><span class="line">        log.info(<span class="string">"开始连接服务器 &#123;&#125;"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        client.connect();</span><br><span class="line">        RPCResponse rpcResponse = client.send(rpcRequest);</span><br><span class="line">        log.info(<span class="string">"请求返回结果 &#123;&#125;"</span>,rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体的代理类中的<code>invoke</code>方法中，设置了RPCRequest对象的属性，并且调用了NettyClient的connect方法。</p>
<p>参考文章<a href="https://juejin.im/post/6844903957622423560#heading-10" target="_blank" rel="noopener">《基于Netty实现RPC框架》</a></p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">如果觉得不错，鼓励作者一下吧</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="../img/pay.png"><img loading="lazy" src="/../img/pay.png" alt="֧支付宝" title="֧支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>陈子枫</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://chenzifeng.com/2020/08/18/%E5%9F%BA%E4%BA%8ENetty%E5%AE%9E%E7%8E%B0RPC/" title="基于Netty实现RPC">http://chenzifeng.com/2020/08/18/%E5%9F%BA%E4%BA%8ENetty%E5%AE%9E%E7%8E%B0RPC/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/09/07/Redis%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/" rel="prev" title="Redis进阶之路"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Redis进阶之路</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/07/01/RPC%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="next" title="RPC协议与序列化/反序列化"><span class="post-nav-text">RPC协议与序列化/反序列化</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+基于Netty实现RPC" target="_blank" rel="noopener">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 陈子枫</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v4.2.1</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.9.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>